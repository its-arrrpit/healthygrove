from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import os
import re
import json
# TensorFlow and related imports are temporarily commented out to focus on frontend
# import tensorflow as tf
# from PIL import Image
import numpy as np
import io

# Initialize the Flask application
app = Flask(__name__, static_folder='static')
CORS(app)  # This is to allow cross-origin requests from your frontend

# Load environment variables from a .env file next to this file (safe no-op if missing)
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), ".env"))
except Exception:
    pass

# Serve the frontend
@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')

# Serve static files (if you have JS/CSS/images in a static folder)
@app.route('/static/<path:path>')
def serve_static(path):
    return send_from_directory('static', path)
CORS(app)  # This is to allow cross-origin requests from your frontend

# For the demo version, we'll use this list of class names without loading the model
# The full list is commented out and replaced with a limited list that matches the frontend database
# class_names = [
#     'Corn_(maize)___Cercospora_leaf_spot Gray_leaf_spot',
#     'Corn_(maize)___Common_rust_',
#     'Corn_(maize)___Northern_Leaf_Blight',
#     'Corn_(maize)___healthy',
#     'Potato___Early_blight',
#     'Potato___Late_blight',
#     'Potato___healthy',
#     'Tomato___Bacterial_spot',
#     'Tomato___Early_blight',
#     'Tomato___Late_blight',
#     'Tomato___Leaf_Mold',
#     'Tomato___Septoria_leaf_spot',
#     'Tomato___Spider_mites Two-spotted_spider_mite',
#     'Tomato___Target_Spot',
#     'Tomato___Tomato_Yellow_Leaf_Curl_Virus',
#     'Tomato___Tomato_mosaic_virus',
#     'Tomato___healthy'
# ]

# Limited list that matches the frontend database
class_names = [
    'Corn_(maize)___Common_rust_',
    'Potato___Early_blight',
    'Tomato___Late_blight',
    'Tomato___Leaf_Mold'
]

# Print a message to indicate we're running in demo mode
print("Running in DEMO mode without TensorFlow. The model will return random predictions.")
model = None  # We'll simulate predictions instead

import random

# Optional Gemini integration
try:
    import google.generativeai as genai  # type: ignore
    _GEMINI_IMPORTED = True
except Exception:
    _GEMINI_IMPORTED = False

def _generate_treatment_with_gemini(crop: str, disease: str):
    """Return a structured treatment plan via Gemini or (None, error) if unavailable."""
    api_key = os.environ.get("GEMINI_API_KEY")
    if not _GEMINI_IMPORTED:
        return None, "Gemini SDK not installed (google-generativeai)."
    if not api_key:
        return None, "GEMINI_API_KEY environment variable not set."

    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel("gemini-1.5-flash")
        prompt = f"""
You are an agronomy assistant. Create a concise, practical, SAFE treatment plan for {crop} with {disease}.
Prioritize low-cost, organic or low-chemical methods. Include:
- materials (clear quantities/units)
- step-by-step instructions (numbered)
- prevention tips
- safety precautions
- when to seek professional help

Output strict JSON with fields:
{{
 "title": "...",
 "summary": "...",
 "materials": ["..."],
 "steps": ["..."],
 "safety": ["..."],
 "prevention": ["..."],
 "disclaimer": "..."
}}
"""
        resp = model.generate_content(prompt)
        text = getattr(resp, "text", "").strip()
        # Extract JSON block if wrapped in prose or code fences
        m = re.search(r"\{[\s\S]*\}", text)
        json_blob = m.group(0) if m else None
        if json_blob:
            try:
                data = json.loads(json_blob)
                return data, None
            except Exception:
                pass
        # Fallback: wrap raw text in a minimal structure
        return {
            "title": f"Treatment plan for {crop} - {disease}",
            "summary": text[:800],
            "materials": [],
            "steps": [],
            "safety": [],
            "prevention": [],
            "disclaimer": "This plan was generated by AI. Validate locally before use."
        }, None
    except Exception as e:
        print("Gemini error:", e)
        return None, "Failed to generate treatment plan."
def _fallback_plan(crop: str, disease: str):
    """Return a pragmatic, organic-first fallback treatment plan."""
    return {
        "title": f"Organic-first plan for {crop} - {disease}",
        "summary": (
            f"This is a locally generated plan tailored for {crop} with {disease}. "
            "It prioritizes cultural practices, sanitation, and low-chemical inputs."
        ),
        "materials": [
            "Clean pruning shears (disinfect with 1:10 bleach solution)",
            "Neem oil (cold-pressed) or neem seed powder",
            "Mild liquid soap (as surfactant)",
            "Compost or well-rotted organic matter",
            "Mulch (straw/leaves) to reduce soil splash",
            "Baking soda (for preventative spray, optional)",
        ],
        "steps": [
            "Remove the most infected leaves/plant parts and dispose away from the field (do not compost heavily infected tissues).",
            "Improve airflow: prune lower leaves touching soil and maintain spacing to help foliage dry quickly.",
            "Prepare neem spray: mix 10 ml neem oil with 1 liter water + a few drops of mild soap; spray both leaf surfaces in the evening.",
            "Avoid overhead watering; water at the base in the morning to reduce leaf wetness duration.",
            "Apply mulch around plants to prevent soil splash and maintain even moisture.",
            "Add a thin layer of compost around the root zone to improve plant vigor and resilience.",
            "Monitor for 5â€“7 days; if symptoms persist, repeat neem spray and consider rotating with baking-soda spray (1 tsp per liter + soap).",
        ],
        "safety": [
            "Wear gloves and eye protection when pruning or spraying.",
            "Do not mix multiple sprays at once; test on a small area first.",
            "Keep sprays away from children and animals; store materials safely.",
        ],
        "prevention": [
            "Rotate crops; avoid planting the same crop in the same spot each season.",
            "Use disease-free seeds/seedlings and resistant varieties when available.",
            "Maintain good field hygiene: remove plant debris and weeds regularly.",
            "Irrigate early and avoid prolonged leaf wetness to limit fungal spread.",
        ],
        "disclaimer": "Fallback plan provided without external AI. Consult local extension services for region-specific advice."
    }

def preprocess_image(image_bytes):
    """
    In demo mode, this function just returns True to indicate that an image was received
    """
    try:
        # Just checking if we have image data, not actually processing it
        if image_bytes:
            return True
        return None
    except Exception as e:
        print(f"Error with image: {e}")
        return None

@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400
    
    file = request.files['file']
    
    # Get crop name if provided
    crop_name = request.form.get('crop_name', '')
    print(f"Received crop name: {crop_name}")

    if file.filename == '':
        return jsonify({'error': 'No file selected for uploading'}), 400

    if file:
        try:
            image_bytes = file.read()
            # In demo mode, just check if we got image data
            if preprocess_image(image_bytes) is None:
                return jsonify({'error': 'Could not process the image.'}), 400

            # If a crop name was provided, use it to filter the possible diseases
            filtered_classes = class_names
            if crop_name:
                filtered_classes = [name for name in class_names if name.lower().startswith(crop_name.lower())]
                if not filtered_classes:  # If no matching diseases found, fall back to all classes
                    filtered_classes = class_names
            
            # Pick a random class from filtered list
            predicted_class_name = random.choice(filtered_classes)
            
            # Generate a random confidence between 75% and 99%
            confidence = random.uniform(0.75, 0.99)

            # Return the result as JSON
            return jsonify({
                'disease': predicted_class_name,
                'confidence': f"{confidence:.2%}",
                'specified_crop': bool(crop_name)  # Indicate if user specified a crop
            })

        except Exception as e:
            print(f"Prediction Error: {e}")
            return jsonify({'error': 'An error occurred during prediction.'}), 500
    
    return jsonify({'error': 'An unknown error occurred.'}), 500


@app.route('/treatment', methods=['POST'])
def treatment():
    """Generate a treatment plan using Gemini given crop and disease names.
    Body: {"crop": "Tomato", "disease": "Late blight"}
    Returns: {"plan": { title, summary, materials[], steps[], safety[], prevention[], disclaimer }}
    """
    try:
        payload = request.get_json(silent=True) or {}
        crop = str(payload.get('crop', '')).strip()
        disease = str(payload.get('disease', '')).strip()
        if not crop or not disease:
            return jsonify({"error": "Missing 'crop' or 'disease'"}), 400

        plan, err = _generate_treatment_with_gemini(crop, disease)
        if err and plan is None:
            # Provide a graceful fallback so the UI still gets a useful plan
            fallback = _fallback_plan(crop, disease)
            return jsonify({"plan": fallback, "source": "fallback", "note": err}), 200
        return jsonify({"plan": plan, "source": "gemini"})
    except Exception as e:
        print("Treatment endpoint error:", e)
        return jsonify({"error": "Internal server error"}), 500


if __name__ == '__main__':
    # Runs the Flask server on localhost, port 5000
    app.run(debug=True, host='0.0.0.0', port=5000)
