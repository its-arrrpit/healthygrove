from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import os
import re
import json
# TensorFlow and related imports are temporarily commented out to focus on frontend
# import tensorflow as tf
# from PIL import Image

# Initialize the Flask application
app = Flask(__name__, static_folder='static')
CORS(app)  # This is to allow cross-origin requests from your frontend

# Load environment variables from a .env file next to this file (safe no-op if missing)
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), ".env"))
except Exception:
    pass

# Serve the frontend
@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')

# Serve static files (if you have JS/CSS/images in a static folder)
@app.route('/static/<path:path>')
def serve_static(path):
    return send_from_directory('static', path)
CORS(app)  # This is to allow cross-origin requests from your frontend

# For the demo version, we'll use this list of class names without loading the model
# The full list is commented out and replaced with a limited list that matches the frontend database
# class_names = [
#     'Corn_(maize)___Cercospora_leaf_spot Gray_leaf_spot',
#     'Corn_(maize)___Common_rust_',
#     'Corn_(maize)___Northern_Leaf_Blight',
#     'Corn_(maize)___healthy',
#     'Potato___Early_blight',
#     'Potato___Late_blight',
#     'Potato___healthy',
#     'Tomato___Bacterial_spot',
#     'Tomato___Early_blight',
#     'Tomato___Late_blight',
#     'Tomato___Leaf_Mold',
#     'Tomato___Septoria_leaf_spot',
#     'Tomato___Spider_mites Two-spotted_spider_mite',
#     'Tomato___Target_Spot',
#     'Tomato___Tomato_Yellow_Leaf_Curl_Virus',
#     'Tomato___Tomato_mosaic_virus',
#     'Tomato___healthy'
# ]

# Limited list that matches the frontend database
class_names = [
    'Corn_(maize)___Common_rust_',
    'Potato___Early_blight',
    'Tomato___Late_blight',
    'Tomato___Leaf_Mold'
]

# Print a message to indicate we're running in demo mode
print("Running in DEMO mode without TensorFlow. The model will return random predictions.")
model = None  # We'll simulate predictions instead

import random

# Optional Gemini integration
try:
    import google.generativeai as genai  # type: ignore
    _GEMINI_IMPORTED = True
except Exception:
    _GEMINI_IMPORTED = False

# Optional offline/free translation fallback (no API key)
try:
    from deep_translator import MyMemoryTranslator, GoogleTranslator  # type: ignore
    _DEEPLITE_IMPORTED = True
except Exception:
    _DEEPLITE_IMPORTED = False

def _generate_treatment_with_gemini(crop: str, disease: str):
    """Return a structured treatment plan via Gemini or (None, error) if unavailable."""
    api_key = os.environ.get("GEMINI_API_KEY")
    if not _GEMINI_IMPORTED:
        return None, "Gemini SDK not installed (google-generativeai)."
    if not api_key:
        return None, "GEMINI_API_KEY environment variable not set."

    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel("gemini-1.5-flash")
        prompt = f"""
You are an agronomy assistant. Create a concise, practical, SAFE treatment plan for {crop} with {disease}.
Prioritize low-cost, organic or low-chemical methods. Include:
- materials (clear quantities/units)
- step-by-step instructions (numbered)
- prevention tips
- safety precautions
- when to seek professional help

Output strict JSON with fields:
{{
 "title": "...",
 "summary": "...",
 "materials": ["..."],
 "steps": ["..."],
 "safety": ["..."],
 "prevention": ["..."],
 "disclaimer": "..."
}}
"""
        resp = model.generate_content(prompt)
        text = getattr(resp, "text", "").strip()
        # Extract JSON block if wrapped in prose or code fences
        m = re.search(r"\{[\s\S]*\}", text)
        json_blob = m.group(0) if m else None
        if json_blob:
            try:
                data = json.loads(json_blob)
                return data, None
            except Exception:
                pass
        # Fallback: wrap raw text in a minimal structure
        return {
            "title": f"Treatment plan for {crop} - {disease}",
            "summary": text[:800],
            "materials": [],
            "steps": [],
            "safety": [],
            "prevention": [],
            "disclaimer": "This plan was generated by AI. Validate locally before use."
        }, None
    except Exception as e:
        print("Gemini error:", e)
        return None, "Failed to generate treatment plan."

def _translate_plan_with_gemini(plan: dict, target_lang: str):
    """Translate a treatment plan JSON into target language using Gemini.
    Returns (translated_plan, error or None). On failure, returns (None, err).
    """
    api_key = os.environ.get("GEMINI_API_KEY")
    if not _GEMINI_IMPORTED:
        return None, "Gemini SDK not installed (google-generativeai)."
    if not api_key:
        return None, "GEMINI_API_KEY environment variable not set."

    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel("gemini-1.5-flash")
        src_json = json.dumps(plan, ensure_ascii=False)
        prompt = f"""
You are a careful translator. Translate the VALUES of this JSON into {target_lang}.
Strict rules:
- Keep the JSON structure and keys exactly the same.
- Preserve numbers, units (ml, liter, grams), and lists count.
- Use easy-to-understand, agriculture-appropriate terms for Indian farmers.
- Do not add extra fields. Return ONLY the JSON.

JSON to translate:
{src_json}
"""
        resp = model.generate_content(prompt)
        text = getattr(resp, "text", "").strip()
        m = re.search(r"\{[\s\S]*\}", text)
        blob = m.group(0) if m else None
        if not blob:
            return None, "Model did not return JSON."
        try:
            translated = json.loads(blob)
            return translated, None
        except Exception as e:
            return None, f"Failed to parse translation JSON: {e}"
    except Exception as e:
        print("Gemini translation error:", e)
        return None, "Translation failed."

def _translate_plan_with_mymemory(plan: dict, target_lang: str):
    """Translate plan using MyMemory (deep_translator). Returns (plan, error)."""
    if not _DEEPLITE_IMPORTED:
        return None, "deep_translator not installed."
    # Normalize codes if needed
    lang = target_lang.lower()
    try:
        translator = MyMemoryTranslator(source='en', target=lang)

        def translate_obj(obj):
            if isinstance(obj, dict):
                return {k: translate_obj(v) for k, v in obj.items()}
            if isinstance(obj, list):
                # batch translate strings when possible to reduce requests
                str_indices = [i for i, v in enumerate(obj) if isinstance(v, str) and v.strip()]
                translated_list = list(obj)
                batch_texts = [obj[i] for i in str_indices]
                if batch_texts:
                    try:
                        results = translator.translate_batch(batch_texts)
                    except Exception:
                        results = [translator.translate(t) for t in batch_texts]
                    for idx, res in zip(str_indices, results):
                        translated_list[idx] = res
                # recurse for non-strings
                for i, v in enumerate(translated_list):
                    if not isinstance(v, str):
                        translated_list[i] = translate_obj(v)
                return translated_list
            if isinstance(obj, str):
                try:
                    return translator.translate(obj) if obj.strip() else obj
                except Exception:
                    return obj
            return obj

        return translate_obj(plan), None
    except Exception as e:
        print("MyMemory translation error:", e)
        return None, "Translation failed."

def _translate_plan_with_google(plan: dict, target_lang: str):
    """Translate plan using GoogleTranslator (deep_translator). Returns (plan, error)."""
    if not _DEEPLITE_IMPORTED:
        return None, "deep_translator not installed."
    lang = target_lang.lower()
    try:
        translator = GoogleTranslator(source='en', target=lang)

        def translate_obj(obj):
            if isinstance(obj, dict):
                return {k: translate_obj(v) for k, v in obj.items()}
            if isinstance(obj, list):
                str_indices = [i for i, v in enumerate(obj) if isinstance(v, str) and v.strip()]
                translated_list = list(obj)
                batch_texts = [obj[i] for i in str_indices]
                if batch_texts:
                    try:
                        results = translator.translate_batch(batch_texts)
                    except Exception:
                        results = [translator.translate(t) for t in batch_texts]
                    for idx, res in zip(str_indices, results):
                        translated_list[idx] = res
                for i, v in enumerate(translated_list):
                    if not isinstance(v, str):
                        translated_list[i] = translate_obj(v)
                return translated_list
            if isinstance(obj, str):
                try:
                    return translator.translate(obj) if obj.strip() else obj
                except Exception:
                    return obj
            return obj

        return translate_obj(plan), None
    except Exception as e:
        print("GoogleTranslator error:", e)
        return None, "Translation failed."
def _fallback_plan(crop: str, disease: str):
    """Return a pragmatic, organic-first fallback treatment plan."""
    return {
        "title": f"Organic-first plan for {crop} - {disease}",
        "summary": (
            f"This is a locally generated plan tailored for {crop} with {disease}. "
            "It prioritizes cultural practices, sanitation, and low-chemical inputs."
        ),
        "materials": [
            "Clean pruning shears (disinfect with 1:10 bleach solution)",
            "Neem oil (cold-pressed) or neem seed powder",
            "Mild liquid soap (as surfactant)",
            "Compost or well-rotted organic matter",
            "Mulch (straw/leaves) to reduce soil splash",
            "Baking soda (for preventative spray, optional)",
        ],
        "steps": [
            "Remove the most infected leaves/plant parts and dispose away from the field (do not compost heavily infected tissues).",
            "Improve airflow: prune lower leaves touching soil and maintain spacing to help foliage dry quickly.",
            "Prepare neem spray: mix 10 ml neem oil with 1 liter water + a few drops of mild soap; spray both leaf surfaces in the evening.",
            "Avoid overhead watering; water at the base in the morning to reduce leaf wetness duration.",
            "Apply mulch around plants to prevent soil splash and maintain even moisture.",
            "Add a thin layer of compost around the root zone to improve plant vigor and resilience.",
            "Monitor for 5–7 days; if symptoms persist, repeat neem spray and consider rotating with baking-soda spray (1 tsp per liter + soap).",
        ],
        "safety": [
            "Wear gloves and eye protection when pruning or spraying.",
            "Do not mix multiple sprays at once; test on a small area first.",
            "Keep sprays away from children and animals; store materials safely.",
        ],
        "prevention": [
            "Rotate crops; avoid planting the same crop in the same spot each season.",
            "Use disease-free seeds/seedlings and resistant varieties when available.",
            "Maintain good field hygiene: remove plant debris and weeds regularly.",
            "Irrigate early and avoid prolonged leaf wetness to limit fungal spread.",
        ],
        "disclaimer": "Fallback plan provided without external AI. Consult local extension services for region-specific advice."
    }

def preprocess_image(image_bytes):
    """
    In demo mode, this function just returns True to indicate that an image was received
    """
    try:
        # Just checking if we have image data, not actually processing it
        if image_bytes:
            return True
        return None
    except Exception as e:
        print(f"Error with image: {e}")
        return None

@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400
    
    file = request.files['file']
    
    # Get crop name if provided
    crop_name = request.form.get('crop_name', '')
    print(f"Received crop name: {crop_name}")

    if file.filename == '':
        return jsonify({'error': 'No file selected for uploading'}), 400

    if file:
        try:
            image_bytes = file.read()
            # In demo mode, just check if we got image data
            if preprocess_image(image_bytes) is None:
                return jsonify({'error': 'Could not process the image.'}), 400

            # If a crop name was provided, use it to filter the possible diseases
            filtered_classes = class_names
            if crop_name:
                filtered_classes = [name for name in class_names if name.lower().startswith(crop_name.lower())]
                if not filtered_classes:  # If no matching diseases found, fall back to all classes
                    filtered_classes = class_names
            
            # Pick a random class from filtered list
            predicted_class_name = random.choice(filtered_classes)
            
            # Generate a random confidence between 75% and 99%
            confidence = random.uniform(0.75, 0.99)

            # Return the result as JSON
            return jsonify({
                'disease': predicted_class_name,
                'confidence': f"{confidence:.2%}",
                'specified_crop': bool(crop_name)  # Indicate if user specified a crop
            })

        except Exception as e:
            print(f"Prediction Error: {e}")
            return jsonify({'error': 'An error occurred during prediction.'}), 500
    
    return jsonify({'error': 'An unknown error occurred.'}), 500


@app.route('/treatment', methods=['POST'])
def treatment():
    """Generate a treatment plan using Gemini given crop and disease names.
    Body: {"crop": "Tomato", "disease": "Late blight"}
    Returns: {"plan": { title, summary, materials[], steps[], safety[], prevention[], disclaimer }}
    """
    try:
        payload = request.get_json(silent=True) or {}
        crop = str(payload.get('crop', '')).strip()
        disease = str(payload.get('disease', '')).strip()
        if not crop or not disease:
            return jsonify({"error": "Missing 'crop' or 'disease'"}), 400

        plan, err = _generate_treatment_with_gemini(crop, disease)
        if err and plan is None:
            # Provide a graceful fallback so the UI still gets a useful plan
            fallback = _fallback_plan(crop, disease)
            return jsonify({"plan": fallback, "source": "fallback", "note": err}), 200
        return jsonify({"plan": plan, "source": "gemini"})
    except Exception as e:
        print("Treatment endpoint error:", e)
        return jsonify({"error": "Internal server error"}), 500


@app.route('/languages', methods=['GET'])
def languages():
    """Return supported UI languages, Indian languages first."""
    langs = [
        {"code": "en", "label": "US English", "region": "US"},
        {"code": "hi", "label": "हिंदी", "region": "IN"},
        {"code": "te", "label": "తెలుగు", "region": "IN"},
        {"code": "ta", "label": "தமிழ்", "region": "IN"},
        {"code": "kn", "label": "ಕನ್ನಡ", "region": "IN"},
        {"code": "ml", "label": "മലയാളം", "region": "IN"},
        {"code": "mr", "label": "मराठी", "region": "IN"},
        {"code": "es", "label": "Español", "region": "ES"},
        {"code": "fr", "label": "Français", "region": "FR"},
        {"code": "pt", "label": "Português", "region": "BR"},
    ]
    return jsonify({"languages": langs})


@app.route('/translate', methods=['POST'])
def translate():
    """Translate a plan to the target language. Body: { plan: {...}, target: "hi" }"""
    try:
        data = request.get_json(silent=True) or {}
        plan = data.get('plan')
        target = str(data.get('target', '')).strip().lower()
        if not isinstance(plan, dict) or not target:
            return jsonify({"error": "Missing 'plan' object or 'target' language code"}), 400

        # Short-circuit if English requested
        if target in ("en", "en-us", "english"):
            return jsonify({"plan": plan, "language": target, "source": "original"})

        # Try Gemini first
        translated, err = _translate_plan_with_gemini(plan, target)
        if translated is not None:
            return jsonify({"plan": translated, "language": target, "source": "gemini"})

        # Fallback 1: GoogleTranslator
        translated2, err2 = _translate_plan_with_google(plan, target)
        if translated2 is not None:
            return jsonify({"plan": translated2, "language": target, "source": "google"})

        # Fallback 2: MyMemory (no key)
        translated3, err3 = _translate_plan_with_mymemory(plan, target)
        if translated3 is not None:
            return jsonify({"plan": translated3, "language": target, "source": "mymemory"})

        # Fallback: return original with note when translation unavailable
        safe = dict(plan)
        note = err or err2 or err3 or "Unavailable"
        safe['disclaimer'] = (safe.get('disclaimer') or '') + "\n(Translation unavailable on server; showing English.)"
        return jsonify({"plan": safe, "language": target, "source": "fallback", "note": note}), 200
    except Exception as e:
        print("Translate endpoint error:", e)
        return jsonify({"error": "Internal server error"}), 500

@app.route('/public-config', methods=['GET'])
def public_config():
    """Return non-sensitive config values for frontend consumption."""
    wa_number = os.environ.get('WHATSAPP_NUMBER', '').strip()
    wa_message = os.environ.get('WHATSAPP_DEFAULT_MESSAGE', 'Hello! I need help diagnosing my crop.').strip()
    return jsonify({
        'whatsapp': {
            'number': wa_number,
            'defaultMessage': wa_message
        }
    })


@app.route('/models', methods=['GET'])
def list_models():
    """Return available on-device models for optional offline inference.
    This is metadata only; actual model files are served from /static/models/* and are small placeholders in this demo.
    """
    base_url = '/static/models'
    models = [
        {
            'id': 'plant-disease-v2-1-0',
            'name': 'Plant Disease Detection v2.1.0',
            'version': '2.1.0',
            'sizeMB': 15.0,
            'accuracy': 92.4,
            'f1': 91.8,
            'inferenceMs': 145,
            'notes': 'Improved accuracy for tomato and potato diseases. Reduced model size by ~15%.',
            'file': f"{base_url}/plant_disease_v2.1.0.bin",
        },
        {
            'id': 'plant-disease-v2-0-30',
            'name': 'Plant Disease Detection v2.0.30',
            'version': '2.0.30',
            'sizeMB': 17.58,
            'accuracy': 91.2,
            'f1': 90.5,
            'inferenceMs': 189,
            'notes': 'Previous stable version with good performance on corn and wheat diseases.',
            'file': f"{base_url}/plant_disease_v2.0.30.bin",
        },
        {
            'id': 'tomato-lite-v1',
            'name': 'Tomato-only Lite v1',
            'version': '1.0.0',
            'sizeMB': 6.2,
            'accuracy': 90.1,
            'f1': 89.0,
            'inferenceMs': 88,
            'notes': 'Tiny model focusing on common tomato diseases. Optimized for low-end devices.',
            'file': f"{base_url}/tomato_lite_v1.bin",
        },
    ]
    # Device hints for the UI
    device = {
        'webgl': True,  # UI should detect real support on client; this is a hint
        'minRamGB': 2,
        'recommendedRamGB': 4,
        'fastDownload': True,
    }
    return jsonify({'models': models, 'device': device})


if __name__ == '__main__':
    # Runs the Flask server on localhost, port 5000
    app.run(debug=True, host='0.0.0.0', port=5000)
